//--------------------------------------------------------------------
// 10. 27 월요일 - 중간시험  
//--------------------------------------------------------------------
// 동적할당(Dynamic Allocation) - dynamic은 run-time으로 해석해야 함
//--------------------------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;

// [문제] 메모리 같은 귀한 자원은 어떤 식으로 사용하나요?

// 메모리 자원은 3단계를 지켜야 한다.
// 1 - 자원을 획득	new			new []
// 2 - 자원을 사용 
// 3 - 자원을 반환	delete		delete []

//--------
int main()
//--------
{
	save("main.cpp");

	int* p;				// STACK : 8 byte의 포인터 변수 선언
	p = new int[100];	// 시작 번지 돌려줌 (ex 330번지, STACK에 있는 p에 저장)
						// free-store : 400 byte 확보 (4 byte * 100)


	// 사용 - 1 부터 100 까지 채운다
	// 330 =======
	//		- 1
	// 334 =======
	//		- 2
	// 338 =======
	//		- 3
	// ...

	delete[] p;			// Memory Manager에게 반환 -> 링크드 리스트에서 해제됨
						// free-store는 여전히 400 byte의 1~100이 남아 있음	
						// p는 여전히 330번지를 가지고 있음 
						// 근데 반환된 번지를 p가 가리키고 있는거임
						// dangling pointer	- 비어있는 번지를 댕글댕글하게 가리키고 있는 포인터

	// delete[] p;		// 한번더 반환? -> 심각한 오류
}