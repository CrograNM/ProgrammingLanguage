중간 이후
======================================================================
<const, volatile>

const, volatile --> cv qualifiers : 자격 부여자

======================================================================
<Dangling Pointer>
delete[] p;

(두 delete 사이엔 수많은 시간과 공간이 있음)

delete[] p;

======================================================================
<CODE Segment>
CODE(TEXT) 세그먼트에 함수, 상수 저장
- 저장된 main 함수 부터 코드 시작
- 멤버 함수도 다른게 아님

- 변수는 CODE가 아니라 DATA 세그먼트에 저장됨
- 함수 내에서 선언된 변수는 STACK 세그먼트에 저장됨

======================================================================
<Syntatic Sugar>
- 사기 문법 (꿀문법)
int* p;
p = new int[num];
...
sum += p[i];  // p[i]는 *(p + sizeof(int) * i) 의 syntatic sugar 이다.

- 멤버함수에서 this 포인터도 syntatic sugar 이다.
this->member_variable
(*this).member_variable
이 this 포인터는 안써도 컴파일러가 자동으로 넣어준다.
***절대 쓰지 말것***

======================================================================
<access modifier>

class Dog { 
// private:  ---> 이거 숨어있음. access modifier
};

// struct도 가능	(하지만 public으로 쓰기 위해 struct 존재)
struct Point { 
private:
	int x; 
	int y; 
};

======================================================================
<스페셜 함수>
클래스에는 6가지 스페셜함수가 있다.
1. STRING()									- default constructor		(기본 생성자)
2. ~STRING()								- destructor				(소멸자)

3. STRING( const STRING& )					- copy constructor			(복사 생성자)
4. STRING& operator=( const STRING& )		- copy assignment operator	(복사 대입 연산자) // 복사 생성자와 짝이되는 녀석이다.

// r-value referece (임시객체 참조자) : && 
5. STRING( STRING&& )						- move constructor			(이동 생성자)
6. STRING& operator=( STRING&& )			- move assignment operator	(이동 대입 연산자) // 이동 생성자와 짝이되는 녀석이다.

======================================================================
<1110>
	
	<STRING s 메모리>
	STRING s { "2025. 11. 10" };
	/*
		STACK
		s|--------------------------------
		 | len = 12		|					8 (패딩 4바이트)
		 |--------------------------------
		 | p = 0x00ffab12	( free store )	8
		 |--------------------------------
		 | id = 1		|					8 (패딩 4바이트)
		 |--------------------------------
			
		 s 위치 : addressof(s) or addressof(s.len)
	*/

	<소멸자>
	if (p != nullptr) { // --> 이럴 필요는 없다 왜냐하면 모던 C++ 에서는 delete nullptr; 은 아무 일도 일어나지 않기 때문이다.
		delete[] p;
		len = 0;		// --> 소멸자에서 이런 짓 하지 말것!!! 쓸때없는 짓
	}

	<깊은복사>
	컴파일러가 자동으로 만들어주는 복사 생성자, 복사 대입 연산자는 얕은복사를 한다.
	이는 포인터 멤버 변수가 있는 클래스에서 문제가 된다. (소멸 순서 문제 등)
	따라서 직접 깊은복사를 구현해 주어야 한다. (복사 생성자, 복사 대입 연산자 오버로딩)

	<range for, const>
	for (STRING str : s)	// 이렇게 하면 복사생성자가 호출되어 임시객체가 만들어짐.
		str.show();			// Range-based for를 쓸 때는 레퍼런스(&)를 붙여주어 복사생성자가 호출되지 않게 하는 것이 좋다.
							// ---> for (STRING& str : s)
						
	// 포인터 레퍼런스는 복사하지 않겠다는 의미. 원격에서 직접 접근할 수 있는 유용한 도구인거다.
	// 읽기 전용으로 쓸 때는 const도 붙여준다.		( const : 읽기만 하겠다는 한정사 )
	for (const STRING& str : s)				// C++ const consistency 
		str.show();
	
	// const, volatile - cv qualifiers

======================================================================
	INT& operator++() {		// 전위증가
		++num;
		return *this;
	}
	INT operator++(int) {	// 후위증가
		INT temp { *this };		// 이전의 나를 저장
		++(*this);				// 나를 1 증가 (반드시 이미 만든 전위증가 연산자를 이용)
		return temp;			// 저장했던 나를 리턴
	}
